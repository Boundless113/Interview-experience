# C++
##  移动拷贝构造函数
好处是1. 不用拷贝，然后销毁。这样可以提升性能。2. 对于一些不能被共享的资源，不能拷贝但是可以移动。
构造时直接引用原始对象的右值，然后销毁原始对象指向这些右值的指针。移动拷贝构造不新增任何内存。
## 移动赋值运算符




## 面向对象

## 内存模型

1. 堆：动态分配存储
2. 栈：局部变量，函数参数，局部常量
3. 静态（全局）：全局静态变量，局部静态变量，全局变量，虚函数表
4. 常量存储区：全局常量，函数指针，常量数组
5. 代码区

## 部分关键字
### static

修饰局部变量：存储在静态区，main运行前分配空间，没有初始值会默认初始化，只初始化一次，多次调用沿用上一次的值
修饰全局变量：存储在静态区，只初始化一次，与普通全局变量相比，作用域改为仅限定义该变量的文件
修饰函数：只在本文件中使用，static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝
修饰成员变量：类变量
修饰成员函数：类方法

### extern
### const

## 模版
## 数组和指针区别：
1. 数组一旦声明，我们就不能再给它赋值，但是我们可以给指针赋值 

2. 用指针定义字符串时，指针所指的字符串会被理解为常量字符串，不能修改。数组定义的字符串则可以修改。 

3. 用sizeof运算符可以计算数组变量的数组大小，但指针指向数组时，只能计算出指针本身大小（单位：字节）

## 结构体对齐：
1. 结构体的起始存储位置必须是能够被该结构体中最大的数据类型所整除。

2. 每个数据成员存储的起始位置是自身大小的整数倍(比如int在32位机为4字节，则int型成员要从4的整数倍地址开始存储)。

3. 结构体总大小（也就是sizeof的结果），必须是该结构体成员中最大的对齐模数的整数倍。若不满足，会根据需要自动填充空缺的字节。

4. 结构体包含另一个结构体成员，则被包含的结构体成员要从其原始结构体内部最大对齐模数的整数倍地址开始存储。(比如struct a里存有struct b，b里有char,int,double等元素,那b应该从8的整数倍开始存储。)

5. 结构体包含数组成员，比如char a[3],它的对齐方式和分别写3个char是一样的，也就是说它还是按一个字节对齐。如果写：typedef char Array[3],Array这种类型的对齐方式还是按一个字节对齐，而不是按它的长度3对齐。

6. 结构体包含共用体成员，则该共用体成员要从其原始共用体内部最大对齐模数的整数倍地址开始存储。


## STL

### 优先队列
```c++
//define a priority_queue
static bool cmp(pair<int, int>& m, pair<int, int>& n) {
        return m.second > n.second;
    }

priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> q(cmp);

//or
struct cmp
{
    // 定义排序规则 
    bool operator() (My_Type a,My_Type b )
    { 
        if(a.x==b.x)return a.y<b.y;
        return a.x<b.x; 
    }
}; 
priority_queue<My_Type, vector<My_Type>, cmp> q; 
```
底层实现为堆




## C++11的新特性

1. auto简化声明，实现自动类型推断。常用例如vector迭代器 类型直接用auto。不能用于函数形参以及数组类型。
2. nullptr代替NULL，用于区分0和NULL。类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型。
3. decltype用于推导表达式的类型（但不计算）。作为函数返回值时比较麻烦，后来在C++14里面可以直接用auto作为返回值。
4. 区间迭代，类似python，用冒号：
```c++
for(auto &i : arr) {    
    std::cout << i << std::endl;
}
```
5. 初始化列表，等号可加可不加；对象的构造函数直接用列表初始化
```c++
int x = {5};
double y {2.75};
short quar[5] {1, 2, 3, 4, 5};
int * ar = new int [4] {2, 3, 4, 5};
class Stump {

private:

            int roots;

            double weight;

public:

            Stump(int r, double w) : roots(r), weight(w) {}

};
Stump s1(3, 15.6);
Stump s2{5, 43.4};
Stump s3 = {4, 32.1}；
```
6. 正则表达式
7. 移动拷贝 
8. 右值引用

