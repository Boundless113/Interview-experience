# C++

## 面向对象

## 部分关键字
### static
### extern
### const

## 模版
## 数组和指针区别：
1. 数组一旦声明，我们就不能再给它赋值，但是我们可以给指针赋值 

2. 用指针定义字符串时，指针所指的字符串会被理解为常量字符串，不能修改。数组定义的字符串则可以修改。 

3. 用sizeof运算符可以计算数组变量的数组大小，但指针指向数组时，只能计算出指针本身大小（单位：字节）

## 结构体对齐：
1. 结构体的起始存储位置必须是能够被该结构体中最大的数据类型所整除。

2. 每个数据成员存储的起始位置是自身大小的整数倍(比如int在32位机为4字节，则int型成员要从4的整数倍地址开始存储)。

3. 结构体总大小（也就是sizeof的结果），必须是该结构体成员中最大的对齐模数的整数倍。若不满足，会根据需要自动填充空缺的字节。

4. 结构体包含另一个结构体成员，则被包含的结构体成员要从其原始结构体内部最大对齐模数的整数倍地址开始存储。(比如struct a里存有struct b，b里有char,int,double等元素,那b应该从8的整数倍开始存储。)

5. 结构体包含数组成员，比如char a[3],它的对齐方式和分别写3个char是一样的，也就是说它还是按一个字节对齐。如果写：typedef char Array[3],Array这种类型的对齐方式还是按一个字节对齐，而不是按它的长度3对齐。

6. 结构体包含共用体成员，则该共用体成员要从其原始共用体内部最大对齐模数的整数倍地址开始存储。
## C++11的新特性

1. auto简化声明，实现自动类型推断。常用例如vector迭代器 类型直接用auto。不能用于函数形参以及数组类型。
2. nullptr代替NULL，用于区分0和NULL。类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型。
3. decltype用于推导表达式的类型（但不计算）。作为函数返回值时比较麻烦，后来在C++14里面可以直接用auto作为返回值。
4. 区间迭代，类似python，用冒号：
```c++
for(auto &i : arr) {    
    std::cout << i << std::endl;
}
```
5. 初始化列表，等号可加可不加；对象的构造函数直接用列表初始化
```c++
int x = {5};
double y {2.75};
short quar[5] {1, 2, 3, 4, 5};
int * ar = new int [4] {2, 3, 4, 5};
class Stump {

private:

            int roots;

            double weight;

public:

            Stump(int r, double w) : roots(r), weight(w) {}

};
Stump s1(3, 15.6);
Stump s2{5, 43.4};
Stump s3 = {4, 32.1}；
```
6. 正则表达式

